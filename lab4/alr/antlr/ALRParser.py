# Generated from ALR.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\16")
        buf.write("y\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\3\2\5\2\32\n\2")
        buf.write("\3\2\6\2\35\n\2\r\2\16\2\36\3\2\5\2\"\n\2\3\3\3\3\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\5\3\65\n\3\3\4\3\4\3\4\7\4:\n\4\f\4\16\4=\13\4\3\5")
        buf.write("\6\5@\n\5\r\5\16\5A\3\5\5\5E\n\5\3\6\3\6\3\6\3\6\5\6K")
        buf.write("\n\6\3\7\5\7N\n\7\3\b\5\bQ\n\b\3\b\3\b\5\bU\n\b\3\b\5")
        buf.write("\bX\n\b\3\b\5\b[\n\b\3\t\5\t^\n\t\3\t\3\t\5\tb\n\t\3\n")
        buf.write("\5\ne\n\n\3\n\3\n\5\ni\n\n\3\13\5\13l\n\13\3\13\3\13\5")
        buf.write("\13p\n\13\3\f\5\fs\n\f\3\f\3\f\5\fw\n\f\3\f\2\2\r\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\2\2\2\u0085\2\31\3\2\2\2\4\64")
        buf.write("\3\2\2\2\6\66\3\2\2\2\bD\3\2\2\2\nJ\3\2\2\2\fM\3\2\2\2")
        buf.write("\16P\3\2\2\2\20]\3\2\2\2\22d\3\2\2\2\24k\3\2\2\2\26r\3")
        buf.write("\2\2\2\30\32\7\16\2\2\31\30\3\2\2\2\31\32\3\2\2\2\32\34")
        buf.write("\3\2\2\2\33\35\5\4\3\2\34\33\3\2\2\2\35\36\3\2\2\2\36")
        buf.write("\34\3\2\2\2\36\37\3\2\2\2\37!\3\2\2\2 \"\7\16\2\2! \3")
        buf.write("\2\2\2!\"\3\2\2\2\"\3\3\2\2\2#$\5\16\b\2$%\7\3\2\2%&\5")
        buf.write("\6\4\2&\'\7\4\2\2\'\65\3\2\2\2()\5\20\t\2)*\7\5\2\2*+")
        buf.write("\5\22\n\2+,\7\4\2\2,\65\3\2\2\2-.\5\20\t\2./\7\5\2\2/")
        buf.write("\60\5\22\n\2\60\61\7\6\2\2\61\62\5\26\f\2\62\63\7\4\2")
        buf.write("\2\63\65\3\2\2\2\64#\3\2\2\2\64(\3\2\2\2\64-\3\2\2\2\65")
        buf.write("\5\3\2\2\2\66;\5\b\5\2\678\7\7\2\28:\5\b\5\29\67\3\2\2")
        buf.write("\2:=\3\2\2\2;9\3\2\2\2;<\3\2\2\2<\7\3\2\2\2=;\3\2\2\2")
        buf.write(">@\5\n\6\2?>\3\2\2\2@A\3\2\2\2A?\3\2\2\2AB\3\2\2\2BE\3")
        buf.write("\2\2\2CE\5\f\7\2D?\3\2\2\2DC\3\2\2\2E\t\3\2\2\2FK\5\16")
        buf.write("\b\2GK\5\20\t\2HK\5\22\n\2IK\5\24\13\2JF\3\2\2\2JG\3\2")
        buf.write("\2\2JH\3\2\2\2JI\3\2\2\2K\13\3\2\2\2LN\7\16\2\2ML\3\2")
        buf.write("\2\2MN\3\2\2\2N\r\3\2\2\2OQ\7\16\2\2PO\3\2\2\2PQ\3\2\2")
        buf.write("\2QR\3\2\2\2RT\7\t\2\2SU\7\16\2\2TS\3\2\2\2TU\3\2\2\2")
        buf.write("UW\3\2\2\2VX\7\r\2\2WV\3\2\2\2WX\3\2\2\2XZ\3\2\2\2Y[\7")
        buf.write("\16\2\2ZY\3\2\2\2Z[\3\2\2\2[\17\3\2\2\2\\^\7\16\2\2]\\")
        buf.write("\3\2\2\2]^\3\2\2\2^_\3\2\2\2_a\7\n\2\2`b\7\16\2\2a`\3")
        buf.write("\2\2\2ab\3\2\2\2b\21\3\2\2\2ce\7\16\2\2dc\3\2\2\2de\3")
        buf.write("\2\2\2ef\3\2\2\2fh\7\f\2\2gi\7\16\2\2hg\3\2\2\2hi\3\2")
        buf.write("\2\2i\23\3\2\2\2jl\7\16\2\2kj\3\2\2\2kl\3\2\2\2lm\3\2")
        buf.write("\2\2mo\7\13\2\2np\7\16\2\2on\3\2\2\2op\3\2\2\2p\25\3\2")
        buf.write("\2\2qs\7\16\2\2rq\3\2\2\2rs\3\2\2\2st\3\2\2\2tv\7\b\2")
        buf.write("\2uw\7\16\2\2vu\3\2\2\2vw\3\2\2\2w\27\3\2\2\2\27\31\36")
        buf.write("!\64;ADJMPTWZ]adhkorv")
        return buf.getvalue()


class ALRParser ( Parser ):

    grammarFileName = "ALR.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'->'", "';'", "':'", "'=>'", "'|'", "'skip'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "NTERMINAL", 
                      "TERMINAL", "FUNC", "REGEXP", "CONSTRUCTOR", "WS" ]

    RULE_start = 0
    RULE_desc = 1
    RULE_rights = 2
    RULE_right = 3
    RULE_member = 4
    RULE_eps = 5
    RULE_nterminal = 6
    RULE_terminal = 7
    RULE_regexp = 8
    RULE_func = 9
    RULE_skip = 10

    ruleNames =  [ "start", "desc", "rights", "right", "member", "eps", 
                   "nterminal", "terminal", "regexp", "func", "skip" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    NTERMINAL=7
    TERMINAL=8
    FUNC=9
    REGEXP=10
    CONSTRUCTOR=11
    WS=12

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def desc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ALRParser.DescContext)
            else:
                return self.getTypedRuleContext(ALRParser.DescContext,i)


        def getRuleIndex(self):
            return ALRParser.RULE_start

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = ALRParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 23
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 22
                self.match(ALRParser.WS)


            self.state = 26 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 25
                    self.desc()

                else:
                    raise NoViableAltException(self)
                self.state = 28 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1,self._ctx)

            self.state = 31
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 30
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ALRParser.RULE_desc

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DescRuleContext(DescContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.DescContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def nterminal(self):
            return self.getTypedRuleContext(ALRParser.NterminalContext,0)

        def rights(self):
            return self.getTypedRuleContext(ALRParser.RightsContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescRule" ):
                return visitor.visitDescRule(self)
            else:
                return visitor.visitChildren(self)


    class DescTerminalContext(DescContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.DescContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def terminal(self):
            return self.getTypedRuleContext(ALRParser.TerminalContext,0)

        def regexp(self):
            return self.getTypedRuleContext(ALRParser.RegexpContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescTerminal" ):
                return visitor.visitDescTerminal(self)
            else:
                return visitor.visitChildren(self)


    class DescSkipContext(DescContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.DescContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def terminal(self):
            return self.getTypedRuleContext(ALRParser.TerminalContext,0)

        def regexp(self):
            return self.getTypedRuleContext(ALRParser.RegexpContext,0)

        def skip(self):
            return self.getTypedRuleContext(ALRParser.SkipContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescSkip" ):
                return visitor.visitDescSkip(self)
            else:
                return visitor.visitChildren(self)



    def desc(self):

        localctx = ALRParser.DescContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_desc)
        try:
            self.state = 50
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                localctx = ALRParser.DescRuleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 33
                self.nterminal()
                self.state = 34
                self.match(ALRParser.T__0)
                self.state = 35
                self.rights()
                self.state = 36
                self.match(ALRParser.T__1)
                pass

            elif la_ == 2:
                localctx = ALRParser.DescTerminalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 38
                self.terminal()
                self.state = 39
                self.match(ALRParser.T__2)
                self.state = 40
                self.regexp()
                self.state = 41
                self.match(ALRParser.T__1)
                pass

            elif la_ == 3:
                localctx = ALRParser.DescSkipContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 43
                self.terminal()
                self.state = 44
                self.match(ALRParser.T__2)
                self.state = 45
                self.regexp()
                self.state = 46
                self.match(ALRParser.T__3)
                self.state = 47
                self.skip()
                self.state = 48
                self.match(ALRParser.T__1)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def right(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ALRParser.RightContext)
            else:
                return self.getTypedRuleContext(ALRParser.RightContext,i)


        def getRuleIndex(self):
            return ALRParser.RULE_rights

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRights" ):
                return visitor.visitRights(self)
            else:
                return visitor.visitChildren(self)




    def rights(self):

        localctx = ALRParser.RightsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_rights)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.right()
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ALRParser.T__4:
                self.state = 53
                self.match(ALRParser.T__4)
                self.state = 54
                self.right()
                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ALRParser.RULE_right

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RightMemberContext(RightContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.RightContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def member(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ALRParser.MemberContext)
            else:
                return self.getTypedRuleContext(ALRParser.MemberContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightMember" ):
                return visitor.visitRightMember(self)
            else:
                return visitor.visitChildren(self)


    class RightEpsContext(RightContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.RightContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def eps(self):
            return self.getTypedRuleContext(ALRParser.EpsContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightEps" ):
                return visitor.visitRightEps(self)
            else:
                return visitor.visitChildren(self)



    def right(self):

        localctx = ALRParser.RightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_right)
        self._la = 0 # Token type
        try:
            self.state = 66
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = ALRParser.RightMemberContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 61 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 60
                    self.member()
                    self.state = 63 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << ALRParser.NTERMINAL) | (1 << ALRParser.TERMINAL) | (1 << ALRParser.FUNC) | (1 << ALRParser.REGEXP) | (1 << ALRParser.WS))) != 0)):
                        break

                pass

            elif la_ == 2:
                localctx = ALRParser.RightEpsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 65
                self.eps()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return ALRParser.RULE_member

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class MemberFuncContext(MemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.MemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def func(self):
            return self.getTypedRuleContext(ALRParser.FuncContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberFunc" ):
                return visitor.visitMemberFunc(self)
            else:
                return visitor.visitChildren(self)


    class MemberRegexpContext(MemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.MemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def regexp(self):
            return self.getTypedRuleContext(ALRParser.RegexpContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberRegexp" ):
                return visitor.visitMemberRegexp(self)
            else:
                return visitor.visitChildren(self)


    class MemberNterminalContext(MemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.MemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def nterminal(self):
            return self.getTypedRuleContext(ALRParser.NterminalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberNterminal" ):
                return visitor.visitMemberNterminal(self)
            else:
                return visitor.visitChildren(self)


    class MemberTerminalContext(MemberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a ALRParser.MemberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def terminal(self):
            return self.getTypedRuleContext(ALRParser.TerminalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMemberTerminal" ):
                return visitor.visitMemberTerminal(self)
            else:
                return visitor.visitChildren(self)



    def member(self):

        localctx = ALRParser.MemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_member)
        try:
            self.state = 72
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = ALRParser.MemberNterminalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.nterminal()
                pass

            elif la_ == 2:
                localctx = ALRParser.MemberTerminalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 69
                self.terminal()
                pass

            elif la_ == 3:
                localctx = ALRParser.MemberRegexpContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 70
                self.regexp()
                pass

            elif la_ == 4:
                localctx = ALRParser.MemberFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 71
                self.func()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EpsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(ALRParser.WS, 0)

        def getRuleIndex(self):
            return ALRParser.RULE_eps

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEps" ):
                return visitor.visitEps(self)
            else:
                return visitor.visitChildren(self)




    def eps(self):

        localctx = ALRParser.EpsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_eps)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 75
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 74
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NterminalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NTERMINAL(self):
            return self.getToken(ALRParser.NTERMINAL, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def CONSTRUCTOR(self):
            return self.getToken(ALRParser.CONSTRUCTOR, 0)

        def getRuleIndex(self):
            return ALRParser.RULE_nterminal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNterminal" ):
                return visitor.visitNterminal(self)
            else:
                return visitor.visitChildren(self)




    def nterminal(self):

        localctx = ALRParser.NterminalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_nterminal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 77
                self.match(ALRParser.WS)


            self.state = 80
            self.match(ALRParser.NTERMINAL)
            self.state = 82
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.state = 81
                self.match(ALRParser.WS)


            self.state = 85
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.CONSTRUCTOR:
                self.state = 84
                self.match(ALRParser.CONSTRUCTOR)


            self.state = 88
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.state = 87
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TerminalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TERMINAL(self):
            return self.getToken(ALRParser.TERMINAL, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def getRuleIndex(self):
            return ALRParser.RULE_terminal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTerminal" ):
                return visitor.visitTerminal(self)
            else:
                return visitor.visitChildren(self)




    def terminal(self):

        localctx = ALRParser.TerminalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_terminal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 90
                self.match(ALRParser.WS)


            self.state = 93
            self.match(ALRParser.TERMINAL)
            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 94
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RegexpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REGEXP(self):
            return self.getToken(ALRParser.REGEXP, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def getRuleIndex(self):
            return ALRParser.RULE_regexp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegexp" ):
                return visitor.visitRegexp(self)
            else:
                return visitor.visitChildren(self)




    def regexp(self):

        localctx = ALRParser.RegexpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_regexp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 97
                self.match(ALRParser.WS)


            self.state = 100
            self.match(ALRParser.REGEXP)
            self.state = 102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 101
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FuncContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNC(self):
            return self.getToken(ALRParser.FUNC, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def getRuleIndex(self):
            return ALRParser.RULE_func

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunc" ):
                return visitor.visitFunc(self)
            else:
                return visitor.visitChildren(self)




    def func(self):

        localctx = ALRParser.FuncContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_func)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 104
                self.match(ALRParser.WS)


            self.state = 107
            self.match(ALRParser.FUNC)
            self.state = 109
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.state = 108
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkipContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(ALRParser.WS)
            else:
                return self.getToken(ALRParser.WS, i)

        def getRuleIndex(self):
            return ALRParser.RULE_skip

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkip" ):
                return visitor.visitSkip(self)
            else:
                return visitor.visitChildren(self)




    def skip(self):

        localctx = ALRParser.SkipContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_skip)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 111
                self.match(ALRParser.WS)


            self.state = 114
            self.match(ALRParser.T__5)
            self.state = 116
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==ALRParser.WS:
                self.state = 115
                self.match(ALRParser.WS)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





